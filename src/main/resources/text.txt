Шаг 1
Создать простое SpringBoot-приложение. В качестве группы
и артефакта проекта можно использовать следующие значения:
groupId — ru.hogwarts, artifact — school.

Шаг 2
1. Создать каталоги model, service, controller в пакете
ru.hogwarts.school. В model создать два класса: Student, Faculty.

Класс **Student** имеет следующие поля:
**Long id, String name, int age.**

Класс **Faculty** имеет следующие поля:
**Long id, String name, String color.**

2. Добавить конструкторы к классам, с помощью которых можно
проинициализировать все поля (создать объект класса через new и
передать в него все параметры).
3. Создать методы для получения и изменения переменных класса.
Сами переменные должны быть private.
Если есть желание, можно добавить свои поля, которые могут быть
вам необходимы.

Шаг 3
1. В каталоге **service** cоздать два класса сервисов для моделей:
StudentService и FacultyService.
2. В каждом из них завести HashMap, в котором следует хранить модели.
 Например Map<Long, Student>.
3. Также создать счетчик идентификатора, который будет
инкрементироваться при каждом добавлении нового объекта модели в
HashMap.
4. В каждом сервисе реализовать CRUD-методы для создания, чтения,
изменения и удаления сущностей.

Шаг 4
1. В каталоге **controller** cоздать два класса контроллеров для
сервисов: StudentController и FacultyController.
2. В них добавить RequestMapping (“student” для StudentController
и “faculty” для FacultyController).
3. В каждом контроллере реализовать эндпоинты для создания,
получения, изменения и удаления сущностей, используя все правила
формирования REST-запросов:
GET-методы для получения данных, POST — для создания…

Шаг 5
1. Добавить фильтрацию студентов по возрасту.
Для этого в StudentController добавить эндпоинт, который принимает
число (возраст — поле age) и возвращает список студентов, у которых
совпал возраст с переданным числом.
2. Добавить фильтрацию факультетов по цвету.
Для этого в FacultyController добавить эндпоинт, который принимает
строку (цвет — поле color) и возвращает список факультетов, у которых
совпал цвет с переданной строкой.

Шаг 6
Добавить swagger к проекту. Для этого добавить зависимость к проекту.
<dependency>
<groupId>org.springdoc</groupId>
<artifactId>springdoc-openapi-ui</artifactId>
<version>1.6.3</version>  //для spring 3 нужна версия >2
</dependency>

Шаг 7
Установить Postman и вызвать все эндпоинты проекта, используя его.
____________________________________________________________________
**Шаг 1**
Установить БД PostgreSQL. Создать базу данных hogwarts. Создать
пользователя student с паролем chocolatefrog.

**Шаг 2**
В application.properties приложения прописать следующие атрибуты:

spring.datasource.url=jdbc:postgresql://localhost:5432/hogwards
spring.datasource.username=student
spring.datasource.password=chocolatefrog
spring.jpa.hibernate.ddl-auto=update
!spring.jpa.show-sql=true

<dependency>
  <groupId>org.postgresql</groupId>
  <artifactId>postgresql</artifactId>
  <version>42.3.2</version>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>

**Шаг 3**
Изменить модели Student и Faculty. К каждому классу добавить
аннотацию @Entity. А к полю id добавить две аннотации:
@Id и @GeneratedValue.
!Конструктор по умолчанию

//@Entity
//конструктор по умолчанию
//геттеры и сеттеры
//поле с @Id


А также создать пакет repository, в котором будут находиться два
интерфейса: StudentRepository и FacultyRepository. Оба этих интерфейса
наследуют JpaRepository. Для интерфейса StudentRepository требуется
указать, что в JpaRepository надо работать с моделью Student.
Для FacultyRepository указать Faculty.

dBeaver https://practicum.yandex.ru/blog/menedzher-baz-dannyh-dbeaver/

**Шаг 4**
В сервисах создать приватные поля репозиториев. Для StudentService
создать StudentRepository. Для FacultyService создать
FacultyRepository.С помощью конструкторов подтягивать зависимости
из контекста спринга (@Autowire).

В сервисах удалить HashMap, который использовали для хранения
данных, и удалить счетчик идентификатора. Вместо них следует
использовать функционал репозиториев.

**Шаг 5**
Проверить все CRUD-запросы через Postman.
________________________________________________________________
**Шаг 1**
Добавить эндпоинт для получения всех студентов, возраст которых
находится в промежутке, пришедшем в запросе, т.е. в GET-запросе
будут передаваться два числа (min и max). Для этого в репозитории
следует создать метод findByAgeBetween().

Добавить эндпоинт для поиска факультета по имени или цвету,
игнорируя регистр, т.е. в GET-запросе будет передана строка,
по которой будет происходить фильтрация.

**Шаг 2**
Подключиться с помощью IDEA к базе данных и выполнить простой
запрос select * from student.

**Шаг 3**
Составить следующие SQL-запросы:

1. Получить всех студентов, возраст которых находится между
10 и 20 (можно подставить любые числа, главное, чтобы нижняя
граница была меньше верхней). //between
2. Получить всех студентов, но отобразить только список их имен.
3. Получить всех студентов, у которых в имени присутствует буква
«О» (или любая другая). //like
4. Получить всех студентов, у которых возраст меньше идентификатора. //age<id
5. Получить всех студентов упорядоченных по возрасту. //order by

В корне проекта создать файл scripts.sql и поместить в него
составленные запросы.

https://sql-academy.org/ru/trainer

**Шаг 4**
Настроить связь ManyToOne между студентами и факультетом. При этом
у модели студента должно быть создано поле Faculty, а у модели
факультета — список студентов.

    @OneToMany(mappedBy = "faculty")
    @JsonIgnore
        private List<Student> students;
    @ManyToOne
    @JoinColumn(name = "faculty_id")
        private Faculty faculty;

Добавить два эндпоинта в соответствующие контроллеры которые позволят:
1. Получить факультет студента
2. Получить студентов факультета
_____________________________________________________________________
**Шаг 1**
Создать модель Avatar. В ней будем хранить аватарки студентов.
В модель добавить следующие поля: Long id, String filePath,
long fileSize, String mediaType, byte[] data, Student student.

**Шаг 2**
Настроить связь OneToOne между моделями Student и Avatar.
Для этого к полю student в модели Avatar добавить аннотацию @OneToOne.
Добавить контроллер, сервис и репозиторий для работы с моделью Avatar.

**Шаг 3**
Добавить три эндпоинта. Первый для загрузки картинки. При загрузке
происходить сохранение данных как в БД, так и на локальный диск.

Второй эндпоинт должен возвращать картинку из БД.

Третий должен возвращать картинку из директории.
_____________________________________________________________________
Шаг 1
Создать класс для тестирования в пакете test. Создать по одному тесту
на каждый эндпоинт контроллера StudentController, используя
TestRestTemplate.

<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>test</scope>
</dependency>

spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.username=test
spring.datasource.password=test
path.to.avatars.folder=./avatars

**Шаг 2**
Создать еще один класс для тестирования в пакете test. Создать по одному
тесту на каждый эндпоинт контроллера FacultyController,
используя WebMvcTest.
________________________________________________________________________
**Шаг 1.** Использование аннотации @Query для вызова SQL из приложения.
Используйте аннотацию @Query и добавьте следующий функционал в проект:
- Возможность получить количество всех студентов в школе.
Эндпоинт должен вернуть число.
- Возможность получить средний возраст студентов. Эндпоинт должен вернуть
число.
- Возможность получать только пять последних студентов. Последние студенты
считаются теми, у кого идентификатор больше других.

**Шаг 2.** Добавление пагинации к аватаркам.
Добавьте пагинацию для репозитория AvatarRepository и контроллер в
AvatartController, чтобы можно было получать списки аватарок постранично.
_________________________________________________________________________
**Шаг 1**
С прошлых уроков у нас есть две таблицы: Student и Faculty. Необходимо
для них создать следующие ограничения:
- Возраст студента не может быть меньше 16 лет.
- Имена студентов должны быть уникальными и не равны нулю.
- Пара “значение названия” - “цвет факультета” должна быть уникальной.
- При создании студента без возраста ему автоматически должно присваиваться
 20 лет.

В корне проекта нужно создать файл scripts421.sql (что значит 4-й курс,
2-й урок, 1-е задание) и поместить в него запросы для создания ограничений.

**Шаг 2**
В этом задании по описанию необходимо спроектировать таблицы.
Описание структуры: у каждого человека есть машина. Причем несколько человек
могут пользоваться одной машиной. У каждого человека есть имя, возраст и
признак того, что у него есть права (или их нет). У каждой машины есть
марка (make), модель (model) и стоимость. Также не забудьте добавить таблицам
первичные ключи и связать их.

В корне проекта нужно создать файл scripts422.sql и поместить в него запросы
для создания таблиц.

**Шаг 3**
Составить первый JOIN-запрос, чтобы получить информацию обо всех студентах
(достаточно получить только имя и возраст студента) школы Хогвартс вместе с
названиями факультетов.

Составить второй JOIN-запрос, чтобы получить только тех студентов, у которых есть
аватарки.

В корне проекта создать файл scripts423.sql и поместить в него запрос.
_________________________________________________________________________________
**Шаг 1**
Добавить Liquibase к проекту. Создать файл для миграций с любым говорящим
названием, которое относится к текущему уроку. В качестве названия можно
использовать, например: lesson-three, course-four-lesson-three,
index-practice и т.д.

<dependency>
    <groupId>org.liquibase</groupId>
    <artifactId>liquibase-core</artifactId>
</dependency>

**Шаг 2**
Добавить два индекса, используя миграции:
1) Индекс для поиска по имени студента.
2) Индекс для поиска по названию и цвету факультета.
_____________________________________________________________________________________
**Шаг 1**
Добавить в каждый метод сервиса сообщение. Сообщение должно говорить о том,
что был вызван метод с определенным названием.
Logger logger = LoggerFactory.getLogger(<class_name>.class);
Например, если вы вызываете метод createStudent, то производить вызов
следующего кода:
    logger.info("Was invoked method for create student");
Если у вас в коде есть исключения, то перед вызовом их стоит записать информацию
в лог, используя необходимый уровень логирования. Например:
    logger.error("There is not student with id = " + id);
Дополнительно постарайтесь добавить логи с уровнем логирования: debug и warning.


**Шаг 2**
Создать контроллер InfoController. Добавить в него один эндпоинт /getPort.
Этот эндпоинт будет возвращать одно значение - порт, на котором запущено приложение.
В application.properties создать (если у вас его нет) свойство server.port = 8080.
Это свойство указывает на порт, который будет использовать приложение. Именно это
значение необходимо возвращать в эндпоинте /getPort

**Шаг 3**
В прошлом задании мы использовали свойство server.port. В этом пункте необходимо
создать два конфигурационных файла.
Каждый файл имеет уникальное значение для порта. Каждый конфигурационный файл будет
относиться к определенному профилю. Таким образом, запуская приложение с различными
профилями ендпоинт /getPort будет возвращать различные значения. Необходимо создать
минимум два профиля.
spring.profiles.active=dev
___________________________________________________________________________________
**Шаг 1**
Добавить эндпоинт для получения всех имен всех студентов, чье имя начинается с
буквы А. В ответе должен находиться отсортированный в алфавитном порядке список
с именами в верхнем регистре. Для получения всех студентов из базы использовать
метод репозитория - findAll().

//отфильтровать имена с А
//сортировка в алфавитном порядке
//в верхнем регистре

**Шаг 2**
Создать эндпоинт, который будет возвращать средний возраст всех студентов. Для
получения информации о всех студентах опять же следует использовать метод
репозитория - findAll().

**Шаг 3**
Создать эндпоинт, который будет возвращать самое длинное название факультета.

**Шаг 4**
Создать эндпоинт (не важно в каком контроллере), который будет возвращать
целочисленное значение. Это значение вычисляется следующей формулой:
int sum = Stream.iterate(1, a -> a +1).limit(1_000_000).reduce(0, (a, b) -> a + b );

Необходимо придумать способ уменьшить время ответа эндпоинта путем модификации
вышеописанного выражения.
___________________________________________________________________________________
**Шаг 1**
Создать эндпоинт для студентов (с любым url), который запускает метод сервиса
(с любым названием). В методе сервиса необходимо получить список всех студентов
и вывести их имена в консоль используя команду System.out.println(). При этом первые
два имени вывести в основном потоке, второе и третье в параллельном потоке. А пятое и
шестое во втором параллельном потоке. В итоге в консоли должен появиться список из
шести имен в порядке, отличном от порядка в коллекции.

**Шаг 2**
Создать еще один эндпоинт и метод в сервисе. Но теперь вывод имени в консоль вынести в
отдельный синхронизированный метод. И так же запустить печать в консоль первых двух имен
в основном потоке, третьего и четвертого в параллельном потоке, четвертого и пятого
во втором параллельном потоке.

В итоге в консоли должен находиться список из имен в том же порядке, что и в коллекции.